# On Requirements for Synchronization of Laboratory Equipment

## Introduction
Synchronization devices play an important role in various laboratory experiments, particularly in fields that require precise timing and coordination among multiple components. These devices allow for laboratory equipment to work together in order to accomplish a common task. In the case for fluid dynamics, accurate and precise timing of equipment is particularly important since minor timing discrepancies can lead to non-insignificant errors in data collection and analysis. This has lead to commercial entities providing synchronizing devices with temporal resolutions often less than ten (10) nanoseconds along with advanced timing capabilities that are well suited for even the most complicated laboratory experiments. However, these devices come at the cost of exceedingly high cost-of-ownerships which limits them to institutions and organizations that are well funded. For example, one commercial synchronizer specialized for fluid flow measurements reportedly had a cost-of-ownership of around $9,000 USD (I. Nepomnyi, personal communication, May 18, 2025). Although some commercial entities have since targeted this barrier to entry with lower cost synchronizer models, these models compromise certain features along with cost-of-ownerships that remain a burden to institutions and organizations that are not well-funded.

The high costs of commercial synchronizing devices has lead to a high degree of ingenuity in the research community. For instance, the author of this brief paper replaced expensive commercial devices with simple Arduino microcontrollers. While such solutions certainly work, they provide a slew of problems associated with custom firmware implementations. For one, these custom devices often provide limited functionality and sometimes even require reconfiguration of the whole device to change timing parameters. Furthermore, most microcontrollers are not well suited for advanced synchronizing applications due to an intrinsic feature of these devices. This creates a gap in the current research equipment market for an easy to use and advanced low-cost synchronizing device.

Microcontrollers are basically serial devices. This means that parallel execution of code requires the use of multiple cores or peripheral devices. In contrast to microcontrollers, complex programmable logic devices (CPLDs) provide a means for efficient execution of parallel code at the expensive of steeper learning curves due to the utilization of hardware design languages. CPLDs are particularly well suited for synchronization devices and have found several uses in different laboratory settings. Nonetheless, CPLDs are time consuming to program and were not investigated in detail during this briefing.

## Design Concepts
The RP2040 and RP2350 microcontrollers designed and fabricated by the Raspberry Pi foundation are somewhat unique devices in that they provide a slew of features that make them very attractive for the purposes of controlling laboratory equipment. These microcontrollers provide an efficient means of general input/output (GPIO) manipulation through programmable input/output (PIO) blocks. PIO blocks allow for fast and efficient manipulation of GPIO pins through low-level means. An important feature of PIO blocks is their ability to run independently from the system clock. This enables for features to be implemented on microcontroller architecture that would otherwise require CPLD or similar devices. The applicability of this microcontroller for the controlling of laboratory equipment was first realized by Starkey et al. (2024) where a pseudoclock and arbitrary pulse generator was implemented with great success. The results from Starkey et al. (2024) provided sufficient evidence to investigate the offerings from the Raspberry Pi foundation for the purpose of engineering an accurate and precise synchronizing device.

The synchronization of laboratory equipment can be broken down into two steps: a synchronization clock source and a pulse generator. A synchronization clock is simply a pulse that occurs at every known timestep to initiate a pulse sequence. Synchronization clocks can be implemented as a mere square wave with a repetition frequency measured in Hertz. The pulse generator is a somewhat more complex as it requires the ability to arbitrarily execute a pulse sequence. These two components allow for the design and implementation of an effective digital pulse generator which could be used to control laboratory equipment. While Starkey et al. (2024) implemented this basic two-component design, their approach requires the utilization of at least two microcontrollers. Instead, two PIO blocks of the RP2040 or RP2350 microcontroller could be utilized for the purposes of combining these two approaches into a singular device. This has the advantage of creating a more compact device that is simpler to construct and program.

## Design Requirements
The effective control of laboratory equipment in both simple and advanced laboratory experiments is no simple feat. The commercial devices often used in these settings mostly provide features and performances that are very good and hard to obtain without in-depth research and design. While the designed synchronizer would most likely not approach performances akin to its commercial counterparts, the synchronizer should still be able to perform most laboratory experiments in a reliable and repeatable manner. This requires the identification of engineering requirements for a device of such cailiber, as seen in Table 1.

Table 1. Engineering Requirements
| Engineering Requirements | Target Value | Justification(s) | 
| --- | --- | --- |
| Power Usage (Watts) | 2.5 W | USB 2.0 can only supply so much voltage (5V @ around 500 mA). |
| Operating Frequency (MHz) | 200 MHz | A 200 MHz operating frequency allows for a 5ns resolution in timing. |
| Internal Clocks | 3 | 3 internal clocks allow for ample room for advanced hardware synchronization. |
| Output Channels | 12 | 12 output channels provide ample room for hardware synchronization. |
| Input Channels | 3 | 3 input channels provide ample room for hardware synchronization. |
| I/O Channel Resistance (Ohms) | 50 Ohms | 50 Ohms seems to be the standard for device synchronization. |
| Clock Divider | 2 - 2^32-1 | Reduce system clock frequency to tune system to lower frequency conditions. |
| Pulse Width (us) | 1 us to 1 s | Most experiments do not require pulse lengths <1 us or >1 s. |
| Trigger Rate (KHz) | .001 KHz to 100 KHz | Most experiments do not require excessive trigger demands. |
| Internal Jitter (ns) | <10 ns | A 10 ns jitter corresponds to a 1% error or less for timing sequences of >1us resolution. |
| Trigger Jitter (ns) | <10 ns | External trigger jitter should be as low as possible to reduce phase error. 10ns jitter corresponds to <1% error for microsecond scale timing resolution. |
| Communication Protocol | USB | USB on-the-go reduces setup complexity and allows for human-readable serialized commands for ease of use. |
| Housing | 3D-printable | All housing parts should be 3D-printable to enable a wider audience to construct these devices. |

While not an exhaustive list, Table 1 serves as a basic guideline when engineering a synchronizing device. The synchronizer device should be easily constructable with minimal expertise on the user side beyond that of soldering electrical components and 3D printer maintenance and usage. Additionally, all selected electrical components should consume minimal power while being quite performant as USB power delivery is somewhat limited (e.g., ~2.5 W for USB 2.0). This requires careful consideration of which electrical component should be utilized in order to satisfy most, if not all, of the engineering requirements. Beyond electrical considerations, the firmware of the microcontroller should provide ample means of flexibility to accommodate most use cases. In the case of fluid flow measurements, trigger rates between pulse sequences could occur at different repetition frequencies or require different external trigger configurations (e.g, see Stasicki et al., 2001). This requires for more advanced firmware design that is currently not possible on Arduino-like platforms without the utilization of secondary peripheral devices.

## Preliminary Device Architecture
The synchronization device, herein coined OpenSync, is a simple and powerful synchronization device targeting the control of laboratory equipment commonly used in fluid flow diagnostics. OpenSync would provide 12 output channels and three input channels that could be mapped between three internal clocks. The core design of OpenSync revolves around the Raspberry Pi Pico 2 development board which utilizes the RP2350 microcontroller. Typically, the microcontroller chip would be soldered onto a custom printed circuit board (PCB) to exploit its full capabilities. However, this would necessitate the acquisition of a PCB reflow oven due to the usage of quad-flat, no leads (QFN) components which cannot be soldered by hand. This issue has been mostly eliminated by soldering the Pico 2 development board directly onto a custom PCB, thus eliminating technical difficulties that could incur from soldering QFN components. The RP2350 microcontroller has a known issue (errata 9) where a temporary latching behavior could be observed for input GPIO pins. This issue has been nearly circumvented in whole by connecting all active GPIO pins to ground via 8K resistors. Thus, the RP2350 microcontroller that is included in the Pico 2 development board has been selected as the best-fit architecture for this project. 

OpenSync would implement a dual architecture pulse logic that exploits the benefits associated with the PIO blocks in the RP2350 microcontroller. Each PIO block contains four state machines that run independent of the main clock. This allows for efficient manipulation of GPIO pins through programs written in a low-level language. For instance, state machines can run programs that utilize a subset of the assembly language coined PIO assembly (pioasm) that contains only seven instructions. Each instruction usually takes a single clock cycle to execute unless the state machine is stalled for one reason or another. This allows for very efficient programs to be written in pioasm that require minimal intervention with the main microcontroller processor. One issue with this configuration is that two PIO blocks cannot communicate between each other. As such, alternative means for synchronizing state machines between PIO blocks would be necessary and will be discussed later.

The dual architecture pulse logic would be implemented in two ways: one PIO block specializing in synchronizing clock sources and another PIO block focused on arbitrary pulse generation. The first PIO block, focused primarily on generating square waves for synchronizing pulse sequences, would utilize three state machines with each one synchronized within a single clock cycle of each other. A basic pioasm program would be loaded into the memory of each state machine and executed with user-defined pulsing parameters. The pioasm program would take five inputs: external trigger pin, external trigger delay, external trigger skip, pulse repetition frequency, and pulse quantity. The control of the external trigger is defined by the first instruction in the pulse repetition frequency array which sets a flag in one of the scratch registers of the pioasm program. The number of external triggers to skipped before triggering is controlled by the first instruction of the pulse quantity array and is stored in a second scratch register for later use. Each state machine operates its own instance of the pioasm program which enables for up to three independent clock signals to be sent simultaneously. The second PIO block focuses on an arbitrary pulse generator capable of producing up to 16 pulses (32 instructions in total) and operates in a similar fashion to the arbitrary pulse generator in Starkey et al. (2024). Similar to the pioasm program in PIO block 1, the three instances of the arbitrary pulse generator pioasm program are mapped to all 12 output channels and are capable of operating asynchronously. However, mapping the state machine from PIO block 1 and PIO block 2 is not possible via firmware due to these blocks operating as independent systems. As such, an unconventional approach could be used to circumvent this issue.

As mentioned above, each PIO block operates mostly independent of each other. This creates a challenge when two PIO blocks are required to communicate between the two to accomplish a certain task. There are several methods to solve this challenge, however the one chosen for this project is somewhat uncommon. An interesting feature of the RP2350 microcontroller is the ability for any input GPIO pin to passively "spy" on the state of another GPIO pin. This GPIO pin can be either configured as an output or input pin as the pin direction does not matter much in this context. This feature can be exploited by selecting three unused GPIO pins as an output pin that is mapped to one of each synchronization clocks in PIO block 1. Now, each pioasm program on PIO block 2 can passively spy on their respective GPIO trigger pin in order to determine when to execute the pulse sequence. Naturally, this method of triggering a pioasm program through stalling the state machine until a start signal is received would be slower on comparison to software interrupts. This is because the internal trigger signal may need up to four clock cycles to be detected due to the implementation of GPIO inputs and outputs in the RP2350 architecture. This has an additional side-effect of which the internal trigger signal must be at least four clock cycles long in order to properly resolve the trigger. Since the internal trigger would theoretically would not be repeated for frequencies >1 MHz at a peak system clock frequency of 200 MHz, a trigger signal of 10 cycles was deemed sufficient for the purpose of synchronizing each channel of PIO block 2. Using this methodology, two PIO blocks can effectively communicate with each other to in order to perform advanced pulse sequencing required in certain fluid flow diagnostic experiments.

## References

 1. RP2350 Datasheet, A Microcontroller by Raspberry Pi. (2023). Raspberry Pi Ltd. https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf
 2. Starkey, P. T., Turnbaugh, C., Miller, P., LeBlanc, K.-J., & Meyer, D. H. (2024). Experimental timing and control using microcontrollers. Review of Scientific Instruments, 95(10). https://doi.org/10.1063/5.0225550
 3. Stasicki, B. and Ehrenfried, K. and Dieterle, L. and Ludwikowski, K. and Raffel, M.  (2001) Advanced syncronization techniques for complex flow field investigations by means of PIV .    4th Intern. Symposium on Particle Image Velocimetry, Göttingen, Germany, September 17-19, 2001.
